''' Section B: Modulo Arithmetic (Modulo addition, Modulo Multiplication) '''
# x mod n = remainder when x is divided by n 
# Modulo Addition - (a+b) mod n
# Module Multiplication - (a x b) mod n
# Modulo Exponentiation - 7 ** 2 % 10 == pow(7,2,10)

''' B.a) '''
taskB1a = 120 % 6
print(">>> How Modulos is used:- 120 % 6 = ", taskB1a)

# B.b) generate elements to compute a table
print("Table-like Modulo Addition of Mod 10 for Digits 0 to 9")
for i in range(0,10):
    for j in range(0,10):
        print((i+j) % 10)
    print(" ")

''' B.c) generates similar table-like for modulo multiplication mod 10 for digits 0 -9 '''
print("Table-like Modulo Multplication of Mod 10 for Digits 0 to 9")
for i in range(0,10):
    for j in range(0,10):
        print((i*j) % 10)
    print(" ")

''' B.d) generate modulo exponentiation mod e.g. 7 ** 2 5 10 or pow(7,2,10) '''
print("Table-like Module Exponentiation of Mod 10 for Digits 0 - 12")
for i in range(0, 13):
    for j in range(0, 13):
        print(pow(i,j,10))
    print(" ")

''' B.e) (i) [(a mod n) + (b mod n)] mod n = (a + b) mod n '''
a = 120
b = 8
n = 3

taskB1_e1_1 = [(a % n) + (b % n)] % n
taskB1_e1_2 = (a + b) % n
if (taskB1_e1_1 == taskB1_e1_2):
    print("if [(a % n) + (b % n)] % n == (a + b) % mod ===> Yes it is truely equivalent !")
else:
    print("if [(a % n) + (b % n)] % n == (a + b) % mod ===> No it's equivalent !!")
# B.e) ii) [(a mod n) − (b mod n)] mod n = (a − b) mod n
taskB1_e2_1 = [(a % n) - (b % n)] % n
taskB1_e2_2 = (a - b) %   n
if(taskB1_e2_1 == taskB1_e1_2):
    print(" if [(a mod n) − (b mod n)] mod n == (a − b) mod n ===> Yes it is truely equivalent !")
else:
    print(" if [(a mod n) − (b mod n)] mod n != (a − b) mod n ===> No it isn't equivalent !!")


# B.e) iii) [(a mod n) × (b mod n)] mod n = (a×b) mod n
taskB1_e3_1 = [(a % n) * (b % n)] % n
taskB1_e3_2 = (a*b) % n
if(taskB1_e3_1 == taskB1_e3_2):
    print("if [(a mod n) × (b mod n)] mod n == (a×b) mod n ===> Yes, it is truely equivalent !")
else:
    print("if [(a mod n) × (b mod n)] mod n != (a×b) mod n ===> No, it isn't truely equivalent !")

''' Functions in Primes
- Plaintext enciphered with the public key can only be deciphered with the private key 
-- Not the only public key encryption but popular!!
-- Public key involves senders & receivers generating keys in pairs
-- Only one of which is publicly shared 
- Public/Private keys are generated by mathematical process involving generated large prime numbers
-- "Strongly probable primes" with 99.99% chance of true primes (Miller-Rabin algorithm)
--- present-day mathematics offers no speedy algorithms for factoring composite numbers with huge prime factors
---- Typically used to send tradtional secret key to recipient using recipient's public key 
----- The message body may then be encrypted wioth some other non-public key algorithm such as IDEA '''

# small primes to demonstrate RSA algorithm
import primes
primes.bigppr()
p = 83          # prime, in secure RSA over 100 digits long
q = 37          # another prime, also huge in actual practice
n = p*q         # n = product of p*q, publicly shared
print(n)        # 3071

r = (p-1)*(q-1)     # used to compute e, and d from e
print(r)            # 2952

e = 25                      # e must be odd w/ npo factors in w/ r
d = primes.invmod(r,e)      # compute d such that d * e mod 4 = 1
print(d)                    # 1417L

print((1417 * 25) % r)      # check ''' 1 '''

plaintext = 1015                    # long messages need to be block-enciphered
ciphertext = pow(plaintext,e,n)     # (e,n) is the public key
print(ciphertext)                   # 752

deciphered = pow(ciphertext,d,n)    # (d,n) is the private key
print(deciphered)                   # 1015
